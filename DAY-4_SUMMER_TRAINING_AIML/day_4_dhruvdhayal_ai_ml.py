# -*- coding: utf-8 -*-
"""Day-4_DHRUVDHAYAL_AI/ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NxtSVhqaCr_RM8Gb88mLkzoRae9jMfvY

#Day-4 Solving the Real-Life Problem Statements.
"""

#Now, we need to develop the Valued Project-2 in Day-4.

#Problem Statement is: We, need to install the random number of sensors at different location randomly.
# -> Task2: Now, we need to give an seperate ID's to each sensors such, that it is quite easy for the identifications.
# -> Task3: Now, we need to find the neighbouring nodes of the main central Node.
# -> Task4: Now, plot the graph and then show the neighbouring node connect it with the main central node.(Distance Formula).
# -> Task5: Make Proper Visualization and also plot it with the help of subgraph , previous graph and then show the plotted graph.

# NOTE: You, can also take the help of chatGPT.

#-------------------------------------------------------- TASK-1 -----------------------------------------------------------

#Task-1 Show all the sensors and plot to show it in the main graph.

#Initializing the Values of the Graph before Plotting.
import numpy as np;
import matplotlib.pyplot as plt;
import seaborn as sns;
import pandas as pd;

#Putting Important formulas to indicate the sensors.
no_of_sensors=10;
np.random.seed(7);
#data=np.random.randint((no_of_sensors,2)); we, use this but 'randint' shows quite discrete value, which removes randomness might be inconvenient,
data=0+(100-0)*np.random.random((no_of_sensors,2));
plt.figure(1);
plt.title("Raw Data about the Sensors");

#Plotting the Main Graph.
plt.plot(data[:,0],data[:,1],'ro'); # - for line, s-star, d-diamond, o-circle(dot), *-star.
plt.grid(True);
#plt.show();

#--------------------------------------------------------- TASK-2 -------------------------------------------------------

#Task-2: Now, we need to show the Identificaton number of the Sensors.
for i in range(data.shape[0]):
  dx=data[i,0];
  dy=data[i,1];
  plt.text(dx-1,dy+2,str(i+1));

#Showing the Valued Graph.
plt.show();

#Now, we need to use the distance formula.
d=10+(20-10)*np.random.random((4,2));
print("\n Matrix of d is: \n\n",d);
print("\n Now, total size of the d: ",d.shape);

print(d[0,:]);
#Print the 0th row of the Matrix.

#Printd the 0th and 1st row of the Matrix only just for the Demonsterations.
print("\n 0th Row of the Matrix : ",d[0,:]);
print("\n 1st Row of the Matrix : ",d[1,:]);

#Performing both the values of the Task-1 & Task-2.
import numpy as np
import matplotlib.pyplot as plt;
import seaborn as sns;
import pandas as pd;

#Putting the Values inside the values of the data;
no_of_sensors=10;
np.random.seed(7);
# data=np.random.randint((no_of_sensors,2)); We, use this but it remove the randomness values might be inconvenient.
data=0+(100-0)*np.random.random((no_of_sensors,2));

#Plotting the Graph Chart by showing the Valued Sensors.
plt.figure(1);
plt.title("Raw Data about the Sensors");
plt.plot(data[:,0],data[:,1],'ro'); #o-circle, d-diamond, *-star,- straight_line, s-square.
plt.grid(True);

#Now, by performing the valued task-3 , we have to find the Identification No, ID's to Identify like: 1,2,3,4,5,....,10.
for i in range(data.shape[0]):
  dx=data[i,0];
  dy=data[i,1];
  plt.text(dx-1,dy+2,str(i+1))

#For, Demonsterations: Calculating and Genrating the Random Matrix.
d=10+(20-10)*np.random.random((4,2));
print("\n 1. Values of the Matrix are: \n\n",d);
print("\n 2. Total Size of the Matrix are: ",d.shape);

# We, can also extract the row data from the given Particular Matrix.
print("\n 1. Showing the 0th Row are: ",d[0,: ]);
print("\n 2. Showing the 1st Row are: ",d[1,: ]);

#Now, We also find the distance between the two-nodes.
#By, using the Distance Formula.
# dist=((x2**2-x1**2)**2 + (y2**2-y1**2)**2);
dist=np.sqrt((data[1,0]-data[0,0])**2 + (data[1,1]-data[0,1])**2);
print("\n --> Total Distance between the two nodes are: ",dist);

#As, of now we need to show the zeros of the main matrix.
dist_matrix=np.zeros((no_of_sensors,no_of_sensors));
print("\n Given Particular Matrix are: \n\n",dist_matrix);

"""#Task-3 Finding the Distance of one w.r.t to others."""

#Task-3: finding the distance for each node w.r.t to another to find thier neigbouring nodes.
dist=0+(100-0)*np.random.random((no_of_sensors,2));
dist_matrix=np.zeros((data.shape[0],data.shape[0]));

#Showing the dIstance from one node to another.
#NOTE: one node compare by own it'self get value 0 because by comparing himself distance is found to be 0. Then all diagonal of the Matrix is found to be 0 again!
for i in range(data.shape[0]):
  for j in range(data.shape[0]):
    dist=np.sqrt((data[i,0]-data[j,0])**2+(data[i,1]-data[j,1])**2);
    dist_matrix[i,j]=dist;

#Now, show the distance of node w.r.t to other's nodes.
print("\n Distance of Node with respect to other: \n\n",dist_matrix.astype(int));

print(dist_matrix.astype(int));

"""#Now, we have the given Sensing Range = 60.
#We, need to find the node, if any node having distance <=60, then replace the value it with '1', unless/untill remains same 0.
"""

#Now, we compare the values to find the dist_matrix it with the sensing range.
neighbour_matrix=np.zeros((data.shape[0],data.shape[0]));
sensing_range=60;
for i in range(data.shape[0]):
  for j in range(data.shape[0]):
    if(i!=j):
      if(dist_matrix[i,j]<=sensing_range):
        neighbour_matrix[i,j]=1;
      else:
        neighbour_matrix[i,j]=0;

#Showing the Neighbour Matrix Values.
print("\n --> Given Values of the Neighbour Matrix: \n\n",neighbour_matrix);

"""#Now, we need take the user as input from the user as node no.
#Then we need to show all the neighbouring nodes of the main_Node searched by the User.
"""

#Now, we need to take user_input as name of node in 'int' forms and then we have the responsibility to show it's neighbouring nodes.
count=0;
node=int(input("\n 1. Enter the Node user want to search for: "));
node=node-1;
temp_neigh=[];
temp_neighbouring_matrix=neighbour_matrix[node,:];
for i in range(temp_neighbouring_matrix.shape[0]):
  if(temp_neighbouring_matrix[i]==1):
    temp_neigh.append(i+1);
    count=count+1;
    print("\n Node: ",i+1);

#Printing all the collection of Data & Informations.
print("\n--------------------------------- OUTPUT ! ---------------------------------------")
print("\n --> Node choosen by the User are: ",node," Neighbouring Nodes: ",temp_neigh);
print("\n --> Neighbouring Nodes: ",temp_neigh);
print("\n --> Total No. of Neighbouring Nodes are: ",count);

"""#Task-4 Now, we knoe the current_node as node entered by the user as well it's neigbouring nodes. Now in this we have to plot the Graph, and join all neighbouring nodes with it's central axis of main current user node."""

# Plotting the graph
plt.figure(figsize=(10, 8));

#Plotting the graph to indicate and show the main node connect it with the Neighbouring node with line and special shape character designs.
for i in range(data.shape[0]):
  dx=data[i,0];
  dy=data[i,1];
  plt.text(dx-1,dy+2,str(i+1), fontsize=12);
  plt.plot(data[node,0],data[node,1],'rd');

#Showing the neighbouring nodes.
for i in range(len(temp_neigh)):
  Xtemp=[data[node,0],data[temp_neigh[i],0]];
  Ytemp=[data[node,1],data[temp_neigh[i],1]];
  plt.plot(Xtemp,Ytemp,'go-',linewidth=2);
  plt.plot(data[temp_neigh[i],0],data[temp_neigh[i],1],'ko');

#Showing the Valued Graphs.
plt.figure(1,(10,8));
plt.title("Raw Data about the Sensors");
plt.xlabel("Sensors");
plt.ylabel("Data Points");
plt.grid(True);

# Setting the axis limits to ensure all nodes appear properly
plt.xlim(np.min(data[:, 0]) - 5, np.max(data[:, 0]) + 5);
plt.ylim(np.min(data[:, 1]) - 5, np.max(data[:, 1]) + 5);

#Showing the Graph as Given Below!
plt.show();

# Plotting the graph
plt.figure(figsize=(10, 8))  # Adjust the figure size if needed

# Plotting the main node and its index
for i in range(data.shape[0]):
    dx = data[i, 0]
    dy = data[i, 1]
    plt.text(dx - 1, dy + 2, str(i + 1), fontsize=12)
    plt.plot(data[node, 0], data[node, 1], 'kd')  # 'bo' for blue circle marker

# Plotting the neighboring nodes
for i in range(len(temp_neigh)):
    Xtemp = [data[node, 0], data[temp_neigh[i], 0]]
    Ytemp = [data[node, 1], data[temp_neigh[i], 1]]
    plt.plot(Xtemp, Ytemp, 'bo-', linewidth=2)  # 'rd-' for red diamond marker and line
    plt.plot(data[temp_neigh[i], 0], data[temp_neigh[i], 1], 'ko')  # 'rs' for red square marker

# Showing the valued graphs
plt.title("Raw Data about the Sensors")
plt.xlabel("Sensors")
plt.ylabel("Data Points")
plt.grid(True)

# Setting the axis limits to ensure all nodes appear properly
plt.xlim(np.min(data[:, 0]) - 5, np.max(data[:, 0]) + 5)
plt.ylim(np.min(data[:, 1]) - 5, np.max(data[:, 1]) + 5)

# Show the plot
plt.show()

"""#Now, We are Implementing the Values of K-Means.
# 1. Manually.
"""

#Create the 50 Nodes Data-Points visualise it in a 2-D Plane, and divide the data it into the 2-Clusters.
#Create the 50 Nodes Data-Points visualise it in a 2-D Plane, and divide the data it into the 4-Clusters.

#Firstly , we create the nodes and plot the graph for proper visualizations.
import numpy as np;
import matplotlib.pyplot as plt;
import seaborn as sns;
import pandas as pd;

#Putting all the Important values in the Graphs.
num=500;
np.random.seed(7);
data=0+(100-0)*np.random.random((num,2));
plt.figure(4,(4,4));
plt.title("Raw Data of K-Map Manually!");
plt.plot(data[ :,0],data[ :,1],'ro');
plt.grid(True);
plt.show();

#Color them half of the cluster of two differrent Shaded Colored!
for i in range(data.shape[0]):
  dxi=data[i,0];
  dyi=data[i,1];
  if(dxi<50):
    plt.plot(dxi,dyi,'ro');
  else:
    plt.plot(dxi,dyi,'bo');

#Show the Valued Graph!
plt.show();

#Now, we have to show the Values of 4-Clusters but of differrent colors.
for i in range(data.shape[0]):
  dxi=data[i,0];
  dyi=data[i,1];
  if(dxi<50):
    if(dyi<50):
      plt.plot(dxi,dyi,'ro');
    else:
      plt.plot(dxi,dyi,'bo');
  else:
    if(dyi<50):
      plt.plot(dxi,dyi,'go');
    else:
      plt.plot(dxi,dyi,'ko');

#Show the Valued Graph!
plt.title("4-Clusters K-Mean (Manually)");
plt.figure(1,figsize=(12,6));
plt.xlabel("Clusters");
plt.ylabel("Data Points");
plt.grid(False);
plt.show();

"""#Now, we are Implementing the Automatic Version of K-Means.
#Clustering with respect to its central centroid.
# 2. Automtic.
"""

#Making the Values of the Automatic Clusters.
num=400;
data=0+(100-0)*np.random.random((num,2));
#Consider data-point 0 at centroid 1.
c1x=data[0,0]; c1y=data[0,1];
c2x=data[1,0]; c2y=data[1,1];

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# all the datapoints
for it in range(10):
  plt.figure(1);
  plt.plot(data[ :,0],data[:,1],'rs');
  #Making of the Clusters.
  Cluster1x=[]; Cluster1y=[];
  Cluster2x=[]; Cluster2y=[];
  for i in range(data.shape[0]):
    d1=np.sqrt((data[i,0]-c1x)**2+(data[i,1]-c1y)**2);
    d2=np.sqrt((data[i,0]-c2x)**2+(data[i,1]-c2y)**2);
    if(d1<d2):
      Cluster1x.append(data[i,0]);
      Cluster1y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'bs');
    else:
      Cluster2x.append(data[i,0]);
      Cluster2y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'gs');
plt.plot(c1x,c1y,'kd');
plt.plot(c2x,c2y,'kd');

#Now, we need to show it with automatic repeatitions.
#Implementing the Actual Values.
num=400;
data=0+(100-0)*np.random.random((num,2));
#Consider Data-Point '0' up with the Centroid Cluster-1.
c1x=data[0,0]; c1y=data[0,1];
#Consider Data-Point '1' up with the Centroid Cluster-2.
c2x=data[1,0]; c2y=data[1,1];

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# All the Data-Points.
for it in range(10):
  plt.figure(1,(10,5));
  plt.plot(data[ :,0],data[ :,1],'rs');
  #Making of the Clusters.
  Cluster1x=[]; Cluster1y=[];
  Cluster2x=[]; Cluster2y=[];
  for i in range(data.shape[0]):
    d1=np.sqrt((c1x-data[i,0])**2 + (c1y-data[i,1])**2);
    d2=np.sqrt((c2x-data[i,0])**2 + (c1y-data[i,1])**2);
    if(d1<d2):
      Cluster1x.append(data[i,0]);
      Cluster1y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'bs');
    else:
      Cluster2x.append(data[i,0]);
      Cluster2y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'gs');

  #Display the Final Graph!
  plt.plot(c1x,c1y,'kd');
  plt.plot(c2x,c2y,'kd');

#Now, Finding the Average of Each.
c1xavg=sum(Cluster1x)/len(Cluster1x);
c1yavg=sum(Cluster1y)/len(Cluster1y);
c2xavg=sum(Cluster2x)/len(Cluster2x);
c2yavg=sum(Cluster2y)/len(Cluster2y);

c1x=c1xavg; c1y=c1yavg;
c2x=c2xavg; c2y=c2yavg;
print(" Iterations: ",str(it));
plt.pause(0.5);

#Now, we need to show it with automatic repeatitions.
#Implementing the Actual Values.
num=400;
data=0+(100-0)*np.random.random((num,2));
#Consider Data-Point '0' up with the Centroid Cluster-1.
c1x=data[0,0]; c1y=data[0,1];
#Consider Data-Point '1' up with the Centroid Cluster-2.
c2x=data[1,0]; c2y=data[1,1];

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# All the Data-Points.
for it in range(10):
  plt.figure(1,(10,5));
  plt.plot(data[ :,0],data[ :,1],'rs');
  #Making of the Clusters.
  Cluster1x=[]; Cluster1y=[];
  Cluster2x=[]; Cluster2y=[];
  for i in range(data.shape[0]):
    d1=np.sqrt((c1x-data[i,0])**2 + (c1y-data[i,1])**2);
    d2=np.sqrt((c2x-data[i,0])**2 + (c1y-data[i,1])**2);
    if(d1<d2):
      Cluster1x.append(data[i,0]);
      Cluster1y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'bs');
    else:
      Cluster2x.append(data[i,0]);
      Cluster2y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'gs');

  #Display the Final Graph!
  plt.plot(c1x,c1y,'kd');
  plt.plot(c2x,c2y,'kd');

  #Now, Finding the Average of Each.
  C1xavg=sum(Cluster1x)/len(Cluster1x); # Dedent this line and subsequent lines
  C1yavg=sum(Cluster1y)/len(Cluster1y);
  C2xavg=sum(Cluster2x)/len(Cluster2x);
  C2yavg=sum(Cluster2y)/len(Cluster2y);

  c1x=C1xavg; c1y=C1yavg;
  c2x=C2xavg; c2y=C2yavg;
  print(" Iterations: ",str(it));
  plt.pause(0.5);

#Now, we need to show it with automatic repeatitions.
#Implementing the Actual Values.
num=400;
data=0+(100-0)*np.random.random((num,2));
#Consider Data-Point '0' up with the Centroid Cluster-1.
c1x=data[0,0]; c1y=data[0,1];
#Consider Data-Point '1' up with the Centroid Cluster-2.
c2x=data[1,0]; c2y=data[1,1];
#Consider Data-Point '1' up with the Centroid Cluster-2.
c3x=data[2,0]; c3y=data[2,1];
#Consider Data-Point '1' up with the Centroid Cluster-2.
c4x=data[3,0]; c4y=data[3,1];

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# All the Data-Points.
for it in range(10):
  plt.figure(1,(10,5));
  plt.plot(data[ :,0],data[ :,1],'rs');
  #Making of the Clusters.
  Cluster1x=[]; Cluster1y=[];
  Cluster2x=[]; Cluster2y=[];
  Cluster3x=[]; Cluster3y=[];
  Cluster4x=[]; Cluster4y=[];
  for i in range(data.shape[0]):
    d1=np.sqrt((c1x-data[i,0])**2 + (c1y-data[i,1])**2);
    d2=np.sqrt((c2x-data[i,0])**2 + (c1y-data[i,1])**2);
    d3=np.sqrt((c3x-data[i,0])**2 + (c3y-data[i,1])**2);
    d4=np.sqrt((c4x-data[i,0])**2 + (c4y-data[i,1])**2);
    if(d1<d2 and d1<d3 and d1<d4):
      Cluster1x.append(data[i,0]);
      Cluster1y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'bs');
    elif(d2<d1 and d2<d3 and d2<d4):
      Cluster2x.append(data[i,0]);
      Cluster2y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'gs');
    elif(d3<d1 and d3<d2 and d3<d4):
      Cluster3x.append(data[i,0]);
      Cluster3y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'rs');
    else:
      Cluster4x.append(data[i,0]);
      Cluster4y.append(data[i,1]);
      plt.plot(data[i,0],data[i,1],'cs');

  #Display the Final Graph!
  plt.plot(c1x,c1y,'kd');
  plt.plot(c2x,c2y,'kd');
  plt.plot(c3x,c3y,'kd');
  plt.plot(c4x,c4y,'kd');

  #Now, Finding the Average of Each.
  C1xavg=sum(Cluster1x)/len(Cluster1x); # Dedent this line and subsequent lines
  C1yavg=sum(Cluster1y)/len(Cluster1y);
  C2xavg=sum(Cluster2x)/len(Cluster2x);
  C2yavg=sum(Cluster2y)/len(Cluster2y);
  C3xavg=sum(Cluster3x)/len(Cluster3x); # Dedent this line and subsequent lines
  C3yavg=sum(Cluster3y)/len(Cluster3y);
  C4xavg=sum(Cluster4x)/len(Cluster4x);
  C4yavg=sum(Cluster4y)/len(Cluster4y);

  c1x=C1xavg; c1y=C1yavg;
  c2x=C2xavg; c2y=C2yavg;
  c3x=C3xavg; c3y=C3yavg;
  c4x=C4xavg; c4y=C4yavg;
  print(" Iterations: ",str(it));
  plt.pause(0.5);

# auto clustering (2 cluster algorithm )
num=400
data = 0+(100-0)*np.random.random((num,2))
# consider datapoint0 as centroid 1
c1x = data[0,0];c1y = data[0,1]
# consider datapoint1 as centroid 2
c2x = data[1,0];c2y = data[1,1]

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# all the datapoints
for it in range(10):
  plt.figure(1,(10,2))
  plt.subplot(1,2,1)
  #plt.title('Raw data')
  plt.plot(data[:,0],data[:,1],'rs')
  Cluster1x=[];Cluster1y=[]
  Cluster2x=[];Cluster2y=[]
  for i in range(data.shape[0]):
    d1 = np.sqrt((c1x-data[i,0])**2 + (c1y-data[i,1])**2)
    d2 = np.sqrt((c2x-data[i,0])**2 + (c2y-data[i,1])**2)
    if(d1<d2):
      Cluster1x.append(data[i,0])
      Cluster1y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'bs')
    else:
      Cluster2x.append(data[i,0])
      Cluster2y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'gs')
  plt.plot(c1x,c1y,'kd') # to plot the centroid1
  plt.plot(c2x,c2y,'kd') # to display the centroid 2
  #print("datapoints in cluster1",len(Cluster1x))
  #print("datapoints in cluster2",len(Cluster2x))

  #step 3
  # now take the average of all the x coord and y coord of both
  # cluster 1 and cluster2
  C1xavg = sum(Cluster1x)/len(Cluster1x)
  C1yavg = sum(Cluster1y)/len(Cluster1y)

  C2xavg = sum(Cluster2x)/len(Cluster2x)
  C2yavg = sum(Cluster2y)/len(Cluster2y)

  # step4
  # update the centroids of cluster 1 and cluster 2 as per their averages
  c1x = C1xavg;c1y = C1yavg
  c2x = C2xavg;c2y = C2yavg
  plt.title(["Iteration number: "+str(it)])
  plt.pause(0.5) # half second delay

# auto clustering (2 cluster algorithm )
num=400
data = 0+(100-0)*np.random.random((num,2))
# consider datapoint0 as centroid 1
c1x = data[0,0];c1y = data[0,1]
# consider datapoint1 as centroid 2
c2x = data[1,0];c2y = data[1,1]
# consider datapoint1 as centroid 2
c3x = data[2,0];c3y = data[2,1]
# consider datapoint1 as centroid 2
c4x = data[3,0];c4y = data[3,1]

# step 2 find the distances of centroid and 1 and centroid 2 with respect to
# all the datapoints
for it in range(10):
  plt.figure(1,(10,2))
  plt.subplot(1,2,1)
  #plt.title('Raw data')
  plt.plot(data[:,0],data[:,1],'rs')
  Cluster1x=[];Cluster1y=[]
  Cluster2x=[];Cluster2y=[]
  Cluster3x=[];Cluster3y=[]
  Cluster4x=[];Cluster4y=[]

  for i in range(data.shape[0]):
    d1 = np.sqrt((c1x-data[i,0])**2 + (c1y-data[i,1])**2)
    d2 = np.sqrt((c2x-data[i,0])**2 + (c2y-data[i,1])**2)
    d3 = np.sqrt((c3x-data[i,0])**2 + (c3y-data[i,1])**2)
    d4 = np.sqrt((c4x-data[i,0])**2 + (c4y-data[i,1])**2)
    if(d1<d2 and d1<d3 and d1<d4):
      Cluster1x.append(data[i,0])
      Cluster1y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'bs');
    elif(d2<d1 and d2<d3 and d2<d4):
      Cluster2x.append(data[i,0])
      Cluster2y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'gs');
    elif(d3<d1 and d3<d2 and d3<d4):
      Cluster3x.append(data[i,0])
      Cluster3y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'ro');
    else:
      Cluster4x.append(data[i,0])
      Cluster4y.append(data[i,1])
      plt.plot(data[i,0],data[i,1],'co');

  plt.plot(c1x,c1y,'kd') # to plot the centroid1
  plt.plot(c2x,c2y,'kd') # to display the centroid 2
  plt.plot(c3x,c3y,'kd') # to display the centroid 2
  plt.plot(c4x,c4y,'kd') # to display the centroid 2
  #print("datapoints in cluster1",len(Cluster1x))
  #print("datapoints in cluster2",len(Cluster2x))

  #step 3
  # now take the average of all the x coord and y coord of both
  # cluster 1 and cluster2
  C1xavg = sum(Cluster1x)/len(Cluster1x)
  C1yavg = sum(Cluster1y)/len(Cluster1y)

  C2xavg = sum(Cluster2x)/len(Cluster2x)
  C2yavg = sum(Cluster2y)/len(Cluster2y)

  C3xavg = sum(Cluster3x)/len(Cluster3x)
  C3yavg = sum(Cluster3y)/len(Cluster3y)

  C4xavg = sum(Cluster4x)/len(Cluster4x)
  C4yavg = sum(Cluster4y)/len(Cluster4y)

  # step4
  # update the centroids of cluster 1 and cluster 2 as per their averages
  c1x = C1xavg;c1y = C1yavg
  c2x = C2xavg;c2y = C2yavg
  c3x = C3xavg;c3y = C3yavg
  c4x = C4xavg;c4y = C4yavg
  plt.title(["Iteration number: "+str(it)])
  plt.pause(0.5) # half second delay

"""#Hence, we have Completed Day-4 at Summer_Internship_With_METAFISER."""